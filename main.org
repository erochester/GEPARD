#+TITLE: Main file for DUNE simulator.
#+AUTHOR: Edward Rochester
#+STARTUP: show2levels

* Imports

#+BEGIN_SRC python :tangle "main.py" :results output
from user import *
import numpy as np
import random
import math
#+END_SRC

* Main Method

Let's define the main methods. For now we ignore the GUI. The plan for the future, however, is to integrate the code with tkinter. Currently, I am more interested in simulating [[cite:&alanezi-2021-incor]] work and comparing it to [[cite:&morel-2019-gener-infor]]. Afterwards, we can compare these works, against "modified" versions.
The goal is to build a modular DES simulator, that is easy to extend, as such I try to keep the main as clean and minimal as possible. It should only call other methods, i.e., parameter instantiation, driver call, logging call, etc.

*Note:* we may want to do a separate simulation on the percentage of users that on average would agree with PP presented in [[cite:&alanezi-2021-incor]]. For simulating the negotiation, we can do it in a back-end and then provide the DES with the data transmitted and the decision, and calculate the rest from there. In this way, we still meet the "realism" expectation, without reformatting the whole simulation to match the [[cite:&alanezi-2021-incor]]. Otherwise, we can simply do the assumed percentage of 1-way, 2-way and no acceptance negotiations.
 

Let's look at parameters that [[cite:&alanezi-2021-incor]] mention within their work and apply them to the DUNE framework:
 - *Environment (E)*: The[[cite:&alanezi-2021-incor]] propose a negotiation protocol that addresses privacy requirements in both individual and group contexts (extension of [[cite:&alanezi-2018-priva-negot]]). Currently, we focus on one of the deployment scenarios, i.e., shopping mall, and, as such, we *should* consider group context. Within it, privacy preferences of each individual are combined into a group privacy profile to be negotiated with IoT owner. The authors consider IoT owner is IoT deployment, and it is with them that the user's negotiate in an automatic manner. In group contexts author's use "least misery" approach and focus on the user with the most stringent requirements. In case the agreement is not achieved, the corresponding users will be notified with suggestions from the IoT owner to obtain their approval in a similar fashion to the individual negotiations. In the individual negotiations, however, if the agreement is not achieved, the users have an option to leave the environment. The PPs are stored in XML. The authors assume privacy-utility trade-off calculations to calculate agreement conditions. In group context the user's announce their privacy preferences to the IoT owner, who then groups the preferences into a matrix and creates a boundary preference following the "least misery" approach. The main limitation of the work is that the authors do not consider /when/ to start the negotiations, which is critical component of the design, and only highlights the downside of non-holistic approaches.
The group context, however, doesn't work for our scenario, as we are looking at a more dynamic scenario, where users come and go as they wish, and group are created and disassembled dynamically. As such, we will focus on individual negotiation. We could, potentially, use group context, alongside our proposal to calculate the profitability and negotiate, but this would modify the original proposal. Could be a potential extension.
 - *Network (N)*: The choice is between WiFi and BLE. The authors argue that for edge and cloud deployments WiFi is more common, while for user deployments BLE is more common. Nohwever, for the group context, the authors admit that both BLE and WiFi are a viable option. We will focus on BLE, as [[cite:&morel-2019-gener-infor]] also focused on BLE, which allows us to simulate both works using same networking module.
 - *IoT Device (D)*: In [[cite:&alanezi-2021-incor]] the IoT owner is communicated with, and the owner represents multitude of sensors. However, for our purposes we only have 1 IoT device to communicate with. Similar to the proposal.

There are no more details provided within the work with respect to user privacy preference assumptions, or anything else. The authors, however, do reference other works, that are common in the literature and, as such, we can make certain assumption on what would be the other parameters, and we will discuss them in more detail as they come up.


** User Generation

To analyze various PA designs, we simulate the proposed designs using DES. The events within this simulation are as follows:
 - *User arrival*: During this time IoT Device/Owner determines if the new user arrival is "good enough" to transmit the data. In the case of [[cite:&alanezi-2021-incor]] and group context, IoT owner simply receives the preferences, arranges them into a matrix and negotiates as is. However, as the scenario is dynamic, we utilize the individual context approach and calculate the utilities from IoT owner and user perspectives to reach the agreement.

First, we initialize the user parameters:
 - We assume average walking speed of 5 km/h (1.4 m/s). We will generate speeds in the range between [0.27, 1.5] m/s, since people have different walking speeds and will vary. 
 - Privacy preferences are taken from Westin's work [[cite:&kumaraguru-2005-priva]], however, they could be extended using Dupree's work mentioned in [[cite:&ulusoy-2022-panol]]. These privacy preferences will determine the number of negotiation rounds and consent probabilities. We follow same percentages as presented in the proposal:
   + If a user belongs to the privacy fundamentalist category, there is a 20.4% chance they consent. Since they are most likely not to consent, they are also most likely to last 2 rounds of negotiation, prolonging it. We do assume that some of them may still consent, as the sensor data may not be in the field of where they are privacy concerned. As such we follow the results of the questionaire presented in [[cite:&phelps-2000-privac-concer]] and split the percentages as follows: 
   + 25% privacy fundamentalists, which, are divided into 20.4% that will consent and 79.6% that will not consent, resulting in 5.1% consenting and 19.9% not consent. Consenting parties, however, will not always consent with 1st round, as such we put 25/75, or 1.28%/3.82% 1st and 2nd round consent, respectively.
   + 55% pragmatists, which will result in 73.55% consent and 26.45% not consent, results in 40.45% consenting and 14.55% not consenting. For pragmatists we follow similar trend as for fundamentalists, however, with reversed percentages, i.e., 75/25, or 30.34%/10.11% 1st and 2nd round consent.
 + 20% unconcerned, which always consent with 1st round.
 - The user arrival times follow Poisson process and arrival and exit locations are generated uniformly randomly. 
 - Each user get assigned s a unique ID.

Following this we generate the defined number of users that will traverse the pre-defined communication and sensing spheres.

#+BEGIN_SRC python :tangle "user.py"
class User:
    
	def __init__(self, id, speed, arr_loc, dep_loc, privacy_label, privacy_coeff):
		self.id = id
		self.speed = speed
		self.arr_loc = arr_loc
		self.dep_loc = dep_loc
		self.privacy_label = privacy_label
		self.privacy_coeff = privacy_coeff

	def updateLocation(self, curr_loc):
		self.curr_loc = curr_loc

	def updateArrivalTime(self, arr_time):
		self.arr_time = arr_time
	
	def updateDepartureTime(self, dep_time):
		self.dep_time = dep_time
#+END_SRC

#+BEGIN_SRC python :tangle "main.py" :results output
def generateUsers(user_num, lmbd, radius, arr_t):
    list_of_users = []
    # For all users that we need to create
    for u in range(0, user_num):
        # Generate the speed
        speed = np.random.uniform(0.27, 1.5)

        # Generate user arrival angle and calculate coordinates on the sensing disk
        arrival_angle = np.random.rand() * np.pi * 2
        x_a = np.cos(arrival_angle) * radius
        y_a = np.sin(arrival_angle) * radius

        # Generate departure angle and calculate coordinates on the sensing disk
        departure_angle = np.random.rand() * np.pi * 2
        x_d = np.cos(departure_angle) * radius
        y_d = np.sin(departure_angle) * radius
        
        privacy_coeff = random.choice([1] * 25 + [2] * 55 + [3] * 20)
        if privacy_coeff == 1:
            privacy_coeff = random.uniform(0.001, 0.03)
            privacy_label = 1
        elif privacy_coeff == 2:
            privacy_label = 3
            privacy_coeff = random.uniform(0.11, 0.15)
        else:
            privacy_label = 2
            privacy_coeff = random.uniform(0.031, 0.10)
    	# Create the user and append to the list
        list_of_users.append(User(u, speed, (x_a, y_a), (x_d, y_d), privacy_label, privacy_coeff))
    
    arrival_time = arr_t

    for i in range(len(list_of_users)):
        # Get the next probability value from Uniform(0,1)
        p = random.random()

        # Plug it into the inverse of the CDF of Exponential(_lamnbda)
        inter_arrival_time = -math.log(1.0 - p) / lmbd

        # Add the inter-arrival time to the arrival time
        arrival_time = arrival_time + inter_arrival_time
        list_of_users[i].updateArrivalTime(arrival_time)

        # Calculate distance between user arrival and departure points
        distance = np.sqrt(
            (
                (list_of_users[i].arr_loc[0] - list_of_users[i].dep_loc[0]) ** 2
                + (list_of_users[i].arr_loc[1] - list_of_users[i].dep_loc[1]) ** 2
            )
        )
        # Calculate departure time
        departure_time = (
            arrival_time + (distance * 1000 / list_of_users[i].speed) / 3600
        )
        list_of_users[i].updateDepartureTime(departure_time)
    return list_of_users


def initializer():
    # temporary values
    user_num = 10
    lmbd = 3
    radius = 100
    arr_t = 0

    list_of_user = generateUsers(user_num, lmbd, radius, arr_t)
    print(list_of_user)


if __name__ == "__main__":
    initializer()
#+END_SRC 

** 1st Event and Driver

At this point we can initialize the driver and 1st event and event times.

#+BEGIN_SRC python :tangle "main.py" :results output
def driver(logger, lists_of_users):
    # Current user list
    curr_users_list = []
    
    # User under review
    uur = 0
    # Current time is the arrival time of the first user (1st event)
    curr_t = lists_of_users[uur].arr_time
    # Append the first user to the list of current users
    curr_users_list.append(lists_of_users[uur])
    
    # Run the simulation until we run out of the users/time
    while curr_t <= lists_of_users[len(lists_of_users) - 1].dep_time:
		# Update current user list (remove the ones that have left the circle)
        for u in curr_users_list:
            if u.dep_time <= curr_t:
                curr_users_list.remove(u)
                
            logger.debug("Current time: " + str(curr_t))
            logger.debug("Current users: " + str(len(curr_users_list)))
            
        # Update current user location
        for u in curr_users_list:
            distance = np.sqrt(
                (u.arr_loc[0] - u.dept_loc[0]) ** 2
                + (u.arr_loc[1] - u.dept_loc[1]) ** 2
            )
            d_coeff = ((curr_t - u.arr_time) * u.speed) / (distance * 1000)
            u.updateLocation(
                (
                    ((1 - d_coeff) * u.arr_loc[0] + (d_coeff * u.dept_loc[0])),
                    ((1 - d_coeff) * u.arr_loc[1] + (d_coeff * u.dept_loc[1])),
                )
            )
#+END_SRC

Now we need to communicate privacy policies to the user and see if the consent. We want to make sure we communicate only with new users. Because this is the part which will vary between the implementations, it goes to a separate module. For now I will make it a method and move it aside later, when I've confirmed the correcteness of the implementation.

** Calculating Privacy Policy Size (Alanezi)

First, we need to calculate the xml sizes for the privacy policies as defined by alanezi. The Privacy policies and preferences are passed around and stored as XML files with <data-in> and <data-out> tags defining the type of data that one party wants to acquire from another party. In our scenario, the IoT owner (shop owner) wants to collect data from the users, while the users do not want to collect any data from the owner. Such scenario is setup for comparison reasons, as not every proposed PA desing allows for owner to user data transfer. Based on analysis performed in [[https://iot-analytics.com/top-10-iot-applications-in-2020/]] and brief presented in [[https://retailnext.net/resources]], it is safe to assume 1 deployed sensor for occupancy tracking and 1 sensor for interior analytics (e.g., allows to understand shoppers paths, actions and behaviour). Additionally, there could be additional sensors related to security, asset tracking, and marketing (e.g., window shopping analytics). Currently, we assume that the IoT owner has deployed only 2 types of sensors, as it seems to be the most common set of products [[https://iot-analytics.com/top-10-iot-applications-in-2020/]]. TInterestingly, the sensors used for collecting this information are video in both cases, as such, they would fall under the same privacy policy category. Nonetheless, the occupancy counting can be also achieved through other sensors, such as BLE, IR, and ultrasonic [[https://www.iotforall.com/occupancy-monitoring-with-iot-sensors]], and, as such, we assume that the occupancy counting occurs through a different sensor. 
*Note*: While [[cite:&alanezi-2021-incor]] do specify priority and ability to clarify an alternative policy, we assume that majority of user's will not specify such policies. Specifying alternative policies would require user's to go though the existing policies and manually enter them, which even at the current stage the user's are not ready to do with much less time consuming privacy related aspects, see user privacy paradox and attitude.
To this extent the privacy policies for IoT user may look something like following:
#+BEGIN_SRC xml
<privacy-policy>
	<data-out>
		<data-out type="video" priority="1">
		<retention>30-days</retention>
		<shared>no</shared>
		<inferred>no<inferred>
	</data-out>
</privacy-policy>
#+END_SRC
*Note*: In this case the user wants for video data to stay in the system for maximum of 30 days, not to be used for inferrence (which such companies as [[https://retailnext.net/resources]] heavily rely on) and no 3rd party sharing (which majority of companies also rely on). This is only an example policy, and users that fall under privacy unconcerned would have more lenient privacy policies.
No looking at IoT owned data policy we could observe something like:
#+BEGIN_SRC xml
<privacy-policy>
	<data-in>
		<data-in type="video" priority="1">
		<retention>1-year</retention>
		<shared>yes</shared>
		<inferred>yes<inferred>
	</data-in>
	<data-in>
		<data-in type="video" priority="2">
		<retention>1-year</retention>
		<shared>no</shared>
		<inferred>yes<inferred>
	</data-in>
	<data-in>
		<data-in type="video" priority="3">
		<retention>30-days</retention>
		<shared>no</shared>
		<inferred>yes<inferred>
	</data-in>
	<data-in>
		<data-in type="video" priority="4">
		<retention>30-days</retention>
		<shared>no</shared>
		<inferred>no<inferred>
	</data-in>
</privacy-policy>
#+END_SRC
*Note*: for IoT owner we specify alternative policies, as the owner may be interested to get as much data as possible from the device, and specifying larger number of alternatives allows to collect even small bits of data even from privacy fundamentalists, which may result in a more "profitable" data points, as these users are less likely to share their information.
In the case of IoT owner, we first collect the data for as long as possible, use it for sharing and inferrence. However, if that doesn't work, we attempt to go to lower priority policies and first, remove the sharing (we still want to store the data and infer from it), second, reduce the number of days we store the data (since it is better to have the data for less time but use it for more purposes), and, finally, we remove the inferrence, so that we at least can keep the recording, for example, for security purposes.
Given the above, we assume that the policy size for IoT user and owner are 217 bytes and 639 bytes respectively.

** Calculating utilities and defining decision making (Alanezi)

The utility-privacy function defined in [[cite:&alanezi-2021-incor]] is as follows:

\begin{equation}
    U = -\gamma * P_e(t,r,s,i) + B(t,r,s,i)
\end{equation}
, where U denotes the total utility. The authors define B to be the benefit from the data exchange as seen from the perspective of the data owner and is calculated as follows:
\begin{equation}
    B = \sum^n_{i=1}[B(t_i)+B(r_i)+B(s_i)+B(i_i)]
\end{equation}
For IoT owner this is a monetary incentive or social benefit, while for IoT user it is benefit from the servicess gained (e.g., discounts or access to premises). Additionally, P defines the degree of privacy exposure for the selected privacy policy. For example, longer retention will be associated with higher privacy exposure, and result in higher P. The P is modelled as the product to reflect the fact that different cofiguration parameters can affect each other with direct proportionality. As such, privacy exposure is defined as:
\begin{equation}
    P_e = \sum^n_{i=1}[P_e(t_i)*P_e(r_i)*P_e(s_i)*P_e(i_i)]
\end{equation}
Finally, $\gamma$ is the overall privacy sensitivity perception factor and will vary depending on the location or context of the negotiation. It is used to escalate or deescalate $P_e$, depending on the specific data sharing situation. 
Unfortunately, authors of work [[cite:&alanezi-2021-incor]] do not provide any specific values to these variables, or how to calculate these values. They do, however, reference work [[cite&preibusch-2006-implem-privac]] as the main inspiration for the utility function. In their work, the authors defined $\gamma$ to be near $1$ for privacy fundamentalists, near $0.5$ for privacy pragmatists, and near $0$ for privacy unconcerned. Consequently, we have to look somewhere else for benefit and cost values. 
Specifically, we need to reflect how values of $t, r, s, i$ change in between the alternative privacy policies. Additionally, we need to also account for the effect $\gamma$ will have on the calculated utility. To this extent we assume the following:
 - Privacy unconcerned will always agree to consent even to PP1
 - Privacy pragmatists will agree to PP2 in $23.55%$ of cases (assumed from the $73.55%$ mentioned above, alongside the questionaire answers within the work [[cite:&phelps-2000-privac-concer]]). They also will consent to PP3 in $50%$ of cases. However, there will be the remaining $23.45%$ of pragmatists that will not agree to PP2 and PP3, and, who, due to only having 2-phase negotiation, will leave the area.
 - Finally, Privacy fundamentalist will consent to PP4 in $20.4%$ of cases (again following the above mentioned distributions), and will not consent to anything else, leaving the area.

As such, for simplicity of the simulations, we assume that the IoT owner will always communicate the respective policies to the correct individuals (we will evaluate the effect of wrong estimation later), and they will at consent or not consent following the above described behaviour. 

** Utilities, policy size, etc. (Morel and Cunche et al.)

The Privacy Beacon (owner) broadcasts 86 bytes PP (using /Advertising/ of BLE). The consent is sent using Attribute Protocol (this changes the power consumption). Consent message consists of MAC address of smartwatch and hash of the owner's PP. User's PP are retrieved between 1-5 seconds after entering the area. User can adjust the broadcasted PP in any way, shape and form and then consent (or not). As such there will be almost 100% of people consenting (except if maybe the fundamentalist makes it impossible to consent). 
The authors do not specify which hash function has been used, so we assume a SHA-$256$ cryptographic hash function. It's output is always $256$ bits long. MAC address is $48$ bits. As such the user consent reply is $304$ bits or $38$ bytes long. 

Due to the setup of the negotiations, we can easily assume that majority of people (given full automated negotiation assumption) will consent to some degree of observation, except for privacy fundamentalists that would never agree to anything. There is also no negotiation phase, as IoT owner will accept anything that user reply to him. As such, we assume that only 19.9% of user's will not consent. As such, if the user is in privacy fundamentalists category, we simply randomly decide if they consent or no with 79.6% probability. 

* Network Modules

** BLE module

Now we need to define the calculation for power consumption using BLE. The work [[cite:&alanezi-2021-incor]] makes use of BLE and BLE beacons. 

There are 2 main consideration when doing simulating BLE:
 1) Even if the user is in the sensing range, they may not be in the communication range (are they close enough to BLE?)
 2) How many negotiation phases are going to occur?

Starting with range BLE 5.0 advertised range is 40m with maximum number of nodes 32,767 ([[link:https://www.researchgate.net/figure/Comparison-Among-Bluetooth-50-Bluetooth-42-and-Other-Typical-Wireless-Communication_tbl2_333528241]]). So we can first filter out any users in range > 40m. We then follow work presented in  ([[link:https://dl.acm.org/doi/pdf/10.1145/3379339?casa_token=NdPKYAGJqUgAAAAA:v1C5C10PiZYPZ6E9f7oag_xbvtxz2fgRTL8DW80NPYFVWGaYxwKHVeqmF7F8eTe5q13ilBPFGTAbLVk]]) that presents a BLE energy model to calculate the power consumption of IoT owner and users, given the number of rounds it takes to communicate the PP. 
*Note*: We will not include sleep and sensor energy consumptions as it will be reflected in energy consumed during transmission times, i.e., more Tx time is spend, the less sleep energy-consumption there will be and vice versa.

Following the work [[link:https://dl.acm.org/doi/pdf/10.1145/3379339?casa_token=NdPKYAGJqUgAAAAA:v1C5C10PiZYPZ6E9f7oag_xbvtxz2fgRTL8DW80NPYFVWGaYxwKHVeqmF7F8eTe5q13ilBPFGTAbLVk]], we distinguish 3 energy consumption events in BLE: 
 1) Energy consumed by Scanner
 2) Energy consumed by Advertiser
 3) Energy consumed by Master and Slave
However, we mostly focus on 3, since that is the energy consumption that is the most affected by negotiation and number of users PP is transmitted to. From work ([[link:https://www.eecs.umich.edu/courses/eecs589/papers/06215496.pdf]]) we can observe that for TX the power consumption is $84$mW (given 3V supply), for RX it is $66$mW and for IFS it is $45$mW. Pre- and post-processing events consume $15$mW and $24$mW, respectively. As such, if we know the number of phases, we can calculate the total energy-consumption of IoT owner and user devices respectively. For now, we ignore the scanner and advertiser power consumptions, we simply assume they are similar in all scenarios and across all BLE implementations, unless stated otherwise.

** LoRa

Now we implement an alternative networking module to see the improvement or downside of it. Specifically, we implement LoRa module, as it is a common alternative to use for low-power long-range communications. One thing to note: the user smartphone by default does not have LoRa communication capabilties and requires an additional module to be installed on it. Luckily, there have been several works addressing this, e.g., [[link:https://www.hackster.io/pulsartronic/diy-smartphone-lora-connection-bde258]] and [[link:https://www.hackster.io/news/this-low-cost-esp8266-lora-gateway-gives-your-smartphone-text-chat-support-even-while-off-grid-4808d2e869b7]]. As such, it is feasible to add LoRa as networking technology to be utilized for PAs. 

Assume same pre- and post-processing power consumption for LoRa and BLE?

For LoRa the power consumption will also vary between SF, BW and CR used. Following work presented in [[link:https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6068831/#FD15-sensors-18-02104]] it is possible to define 3 modes of LoRa - largest distance mode (SF12, 125kHz), intermediate mode (SF10,250kHz) and minimum range mode (SF7,500kHz). The energy consumption per transmission in each of the modes are defined in [[link:https://hal.archives-ouvertes.fr/hal-01828769/document]] and [[link:https://www.mdpi.com/1424-8220/17/10/2364/htm]]. However, as we do not transmit for distances larger than 500 m, then the main determining factor for modes would be the payload size and current consumption. To this extent, we will utilize the SF that can accomodate the PP to be sent in 1 packet. Specifically, we can calculate the time it takes to transmit $x$ bytes of payload given CF, CR and BW, as follows:
\begin{equation}
T_{tx} = T_{pre} + T_{PHY}
\end{equation}
, where
\begin{equation}
T_{pre} = T_{sym} * (N_{pre} + 4.25)
\end{equation}
, and 
\begin{equation}
T_{PHY} = T_{sym} * N_{PHY}
\end{equation}
We calculate $T_{sym}$ as follows:
\begin{equation}
T_{sym} = \frac{2^{SF}}{BW}
\end{equation}
and $N_{PHY}$ as:
\begin{equation}
N_{PHY} = 8 + max[ceil[\frac{28+8*PL+16*CRC-4*SF}{4*(SF-2*DE)}]*(CR+4), 0]
\end{equation}
Given the times and taking into account SX1272 specifications [[link:https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/440000001NCE/v_VBhk1IolDgxwwnOpcS_vTFxPfSEPQbuneK3mWsXlU]], we can then calculate the power consumptions as $T \times I\ times U$.
Specifically, SX1272 has 10.5 mA current consumption in receive mode and 18-125 mA current consumption in transmit mode, depending on transmission power. SX1272 uses 3.3V supply. 

* Metrics

The metrics that were proposed for the Candidacy are:
 - Accuracy
 - Energy-efficiency
 - Profitability
 - Coverage
 - Effect Size

 For now we will focus on *energy-efficiency* and *coverage*. *Profitability* will have to be defined in a way to be applicable in all proposed methodologies and, as such, will be measured when other works are implemented. *Effect size* I need to research more on how precisely to do it in simulator (look at Baarslag). *Accuracy* for now is also ignored, as we assume perfect knowledge from IoT owner. 

* Notes

 + Not all users generated will be in range of communication technology. If the sensing range of video camera is assumed to be 100m, but we use BLE to communicate, then we will observe people outside of the communication and consent range. Even if we assume within the market stall installed CCTV, it will still observe people outside the store and outside of communication range.]
 
 + Because the users are within the communication and sensing areas in 10s of seconds (sometimes 100s), we can ignore the negotiation delays, as Alanezi et.al. in work [[cite:&alanezi-2021-incor]] have shown that the 2-phase negotiation would take at most ~$1500$ms.

 + For user arrival process we can consider small, medium and large businesses. We can also consider average day vs holiday season.